#!/bin/bash
# Health check for Faelight Forest 0-core - Enhanced v3.3.4

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

# Counters
total_checks=0
passed=0
failed=0
warnings=0

omarchy_version=$(cat ~/0-core/VERSION 2>/dev/null || echo "unknown")

echo -e "${CYAN}üè• Dotfile Health Check - Faelight Forest v${omarchy_version}${NC}"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

# Check 1: Stow Symlinks
echo -e "${CYAN}üîó Checking Stow symlinks...${NC}"
stowed=0
config_dir_packages="hypr waybar mako foot yazi"
for pkg in $config_dir_packages; do
  [ -L ~/.config/$pkg ] && ((stowed++))
done

# Fish or Zsh (we're in one of them!)
if [ -L ~/.config/fish ] || [ -L ~/.config/zsh ]; then
  ((stowed++))
fi

# Starship
[ -L ~/.config/starship.toml ] && ((stowed++))

# Git
[ -L ~/.gitconfig ] && ((stowed++))

total_packages=8
echo -e "   ${GREEN}‚úÖ All $stowed/$total_packages packages properly stowed${NC}"
((total_checks++))
((passed++))

# Check 2: Yazi Plugins
echo -e "${CYAN}üîå Checking Yazi plugins...${NC}"
yazi_plugins="full-border.yazi git.yazi jump-to-char.yazi smart-enter.yazi"
yazi_count=0
for plugin in $yazi_plugins; do
  [ -d ~/.config/yazi/plugins/$plugin ] && ((yazi_count++))
done

if [ $yazi_count -eq 4 ]; then
  echo -e "   ${GREEN}‚úÖ All 4 plugins installed${NC}"
  ((passed++))
else
  echo -e "   ${YELLOW}‚ö†Ô∏è  Only $yazi_count/4 plugins installed${NC}"
  ((warnings++))
fi
((total_checks++))

# Check 3: Broken Symlinks (only in managed directories)
echo -e "${CYAN}üîó Checking for broken symlinks...${NC}"
managed_dirs="hypr waybar mako foot yazi fish zsh"
broken=0
for dir in $managed_dirs; do
  if [ -d ~/.config/$dir ]; then
    broken=$((broken + $(find ~/.config/$dir -xtype l 2>/dev/null | wc -l)))
  fi
done
if [ $broken -eq 0 ]; then
  echo -e "   ${GREEN}‚úÖ No broken symlinks found${NC}"
  ((passed++))
else
  echo -e "   ${RED}‚ùå Found $broken broken symlinks${NC}"
  ((failed++))
fi
((total_checks++))

# Check 4: System Services (or processes)
echo -e "${CYAN}üîÑ Checking system services...${NC}"
services_ok=0

# Check mako (systemd OR process)
if systemctl --user is-active --quiet mako 2>/dev/null || pgrep -x mako >/dev/null; then
  ((services_ok++))
fi

# Check waybar (systemd OR process)
if systemctl --user is-active --quiet waybar 2>/dev/null || pgrep -x waybar >/dev/null; then
  ((services_ok++))
fi

if [ $services_ok -ge 2 ]; then
  echo -e "   ${GREEN}‚úÖ All $services_ok/2 services running${NC}"
  ((passed++))
else
  echo -e "   ${YELLOW}‚ö†Ô∏è  Only $services_ok/2 services running${NC}"
  ((warnings++))
fi
((total_checks++))

# Check 5: Binary Dependencies
echo -e "${CYAN}üì¶ Checking binary dependencies...${NC}"
binaries="nvim eza bat fd fzf yazi lazygit fastfetch hyprctl waybar mako starship git stow direnv"
bin_count=0
for bin in $binaries; do
  command -v $bin >/dev/null 2>&1 && ((bin_count++))
done

total_bins=$(echo $binaries | wc -w)
if [ $bin_count -eq $total_bins ]; then
  echo -e "   ${GREEN}‚úÖ All $bin_count binaries found${NC}"
  ((passed++))
else
  echo -e "   ${YELLOW}‚ö†Ô∏è  Found $bin_count/$total_bins binaries${NC}"
  ((warnings++))
fi
((total_checks++))

# Check 6: Git Repository Health
echo -e "${CYAN}üìä Checking Git repository health...${NC}"
cd ~/0-core
git update-index --refresh >/dev/null 2>&1 # Refresh index cache
git_issues=0

if ! git diff-index --quiet HEAD -- 2>/dev/null; then
  echo -e "   ${YELLOW}‚ö†Ô∏è  Uncommitted changes${NC}"
  echo "      Run 'git status' to see changes"
  ((git_issues++))
else
  echo -e "   ${GREEN}‚úÖ Working tree clean${NC}"
fi

LOCAL=$(git rev-parse @ 2>/dev/null)
REMOTE=$(git rev-parse @{u} 2>/dev/null)

if [ "$LOCAL" != "$REMOTE" ]; then
  echo -e "   ${YELLOW}‚ö†Ô∏è  Local != Remote${NC}"
  echo "      Run 'git push' or 'git pull'"
  ((git_issues++))
else
  echo -e "   ${GREEN}‚úÖ All commits pushed${NC}"
fi

if [ $git_issues -eq 0 ]; then
  ((passed++))
else
  ((warnings++))
fi
((total_checks++))

# Check 7: Theme Packages
echo -e "${CYAN}üé® Checking theme packages...${NC}"
theme_count=0
[ -d ~/0-core/theme-gtk ] && ((theme_count++))
[ -d ~/0-core/theme-term-foot-dark ] && ((theme_count++))
[ -d ~/0-core/theme-launch-fuzzel-dark ] && ((theme_count++))

if [ $theme_count -eq 3 ]; then
  echo -e "   ${GREEN}‚úÖ 3/3 theme packages present${NC}"
  ((passed++))
else
  echo -e "   ${YELLOW}‚ö†Ô∏è  Only $theme_count/3 theme packages present${NC}"
  ((warnings++))
fi
((total_checks++))

# Check 8: Scripts Executable
echo -e "${CYAN}üìú Checking scripts...${NC}"
scripts="core-protect safe-update dotctl"
script_issues=0
for script in $scripts; do
  if [ ! -x ~/0-core/scripts/$script ]; then
    ((script_issues++))
  fi
done

if [ $script_issues -eq 0 ]; then
  echo -e "   ${GREEN}‚úÖ All scripts present and executable${NC}"
  ((passed++))
else
  echo -e "   ${YELLOW}‚ö†Ô∏è  $script_issues scripts have issues${NC}"
  ((warnings++))
fi
((total_checks++))

# Check 9: Config Aging Report
echo -e "${CYAN}üìÖ Checking config aging...${NC}"

# Count files by age
recent=0  # < 30 days
aging=0   # 30-90 days
stale=0   # 90-365 days
ancient=0 # 1+ year

# Check 10: Intentional Defaults (Discipline Enforcement)
echo -e "${CYAN}üéØ Checking intentional defaults...${NC}"

issues=0

# Check for non-semantic filenames
non_semantic=$(find ~/0-core -maxdepth 3 -type f \( -name "temp*" -o -name "new-*" -o -name "old-*" -o -name "backup*" -o -name "test*" -o -name "tmp*" \) -not -path '*/\.git/*' 2>/dev/null)

if [[ -n "$non_semantic" ]]; then
  echo -e "   ${RED}‚ùå Non-semantic filenames found:${NC}"
  while IFS= read -r file; do
    echo -e "      ${DIM}$(basename "$file")${NC}"
    ((issues++))
  done <<<"$non_semantic"
else
  echo -e "   ${GREEN}‚úÖ All filenames are semantic${NC}"
fi

# Check for truly non-semantic directories (random temp stuff)
# Exclude known good directories: docs, scripts, and semantic packages
bad_dirs=$(find ~/0-core -maxdepth 1 -type d -not -name ".*" -not -name "0-core" | while read -r dir; do
  dirname=$(basename "$dir")
  # Exclude known infrastructure directories
  if [[ "$dirname" == "docs" ]] || [[ "$dirname" == "scripts" ]] || [[ "$dirname" == "hooks" ]] || [[ "$dirname" == "system" ]] || [[ "$dirname" == "packages" ]] || [[ "$dirname" == "installation" ]] || [[ "$dirname" == "automation" ]]; then
    continue
  fi
  # Exclude semantic package names (prefix-name pattern)
  if [[ "$dirname" =~ ^[a-z]+-[a-z] ]]; then
    continue
  fi
  # Flag anything else as potentially non-semantic
  echo "$dir"
done)

if [[ -n "$bad_dirs" ]]; then
  echo -e "   ${YELLOW}‚ö†Ô∏è  Non-semantic directories found:${NC}"
  while IFS= read -r dir; do
    echo -e "      ${DIM}$(basename "$dir")${NC}"
    ((issues++))
  done <<<"$bad_dirs"
else
  echo -e "   ${GREEN}‚úÖ All directories follow semantic naming${NC}"
fi

# Check for packages without .dotmeta
packages_without_meta=$(find ~/0-core -maxdepth 1 -type d -not -name ".*" -not -name "0-core" | while read -r pkg; do
  dirname=$(basename "$pkg")
  # Only check semantic package directories (prefix-name pattern)
  if [[ "$dirname" =~ ^[a-z]+-[a-z] ]]; then
    if [[ ! -f "$pkg/.dotmeta" ]]; then
      echo "$dirname"
    fi
  fi
done)

if [[ -n "$packages_without_meta" ]]; then
  echo -e "   ${YELLOW}‚ö†Ô∏è  Packages missing .dotmeta:${NC}"
  while IFS= read -r pkg; do
    echo -e "      ${DIM}$pkg${NC}"
    ((issues++))
  done <<<"$packages_without_meta"
else
  echo -e "   ${GREEN}‚úÖ All packages have .dotmeta${NC}"
fi

# Count this check
((total_checks++))
if [[ $issues -eq 0 ]]; then
  echo -e "   ${GREEN}‚úÖ Intentional defaults maintained${NC}"
  ((passed++))
else
  echo -e "   ${YELLOW}‚ö†Ô∏è  $issues discipline issues found${NC}"
  ((warnings++))
fi

# Check all files in 0-core (exclude .git)
while IFS= read -r file; do
  if [[ -f "$file" ]]; then
    # Get days since last modification
    days=$((($(date +%s) - $(stat -c %Y "$file" 2>/dev/null || stat -f %m "$file")) / 86400))

    if [[ $days -lt 30 ]]; then
      ((recent++))
    elif [[ $days -lt 90 ]]; then
      ((aging++))
    elif [[ $days -lt 365 ]]; then
      ((stale++))
    else
      ((ancient++))
    fi
  fi
done < <(find ~/0-core -type f -not -path '*/\.git/*' 2>/dev/null)

total_files=$((recent + aging + stale + ancient))

echo -e "   Recent (< 30 days):    ${GREEN}$recent files${NC}"
echo -e "   Aging (30-90 days):    ${YELLOW}$aging files${NC}"
echo -e "   Stale (90-365 days):   ${YELLOW}$stale files${NC}"

if [[ $ancient -gt 0 ]]; then
  echo -e "   Ancient (1+ year):     ${RED}$ancient files${NC}"
else
  echo -e "   Ancient (1+ year):     ${GREEN}$ancient files${NC}"
fi

echo -e "   ${DIM}Total tracked: $total_files files${NC}"

# Count this check
((total_checks++))
((passed++))

# Final Report
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

if [ $failed -gt 0 ]; then
  echo -e "${RED}‚ùå System has issues ($failed failed checks)${NC}"
elif [ $warnings -gt 0 ]; then
  health=$(awk "BEGIN {printf \"%.6f\", ($passed / $total_checks) * 100}")
  echo -e "${YELLOW}‚ö†Ô∏è  System mostly healthy ($health%)${NC}"
else
  echo -e "${GREEN}‚úÖ System healthy! All checks passed! üå≤${NC}"
fi

echo "Statistics:"
echo "   Passed:   $passed"
echo "   Failed:   $failed"
echo "   Warnings: $warnings"
echo "   Total:    $total_checks"
health=$(awk "BEGIN {printf \"%.6f\", ($passed / $total_checks) * 100}")
echo "   Health:   $health%"
